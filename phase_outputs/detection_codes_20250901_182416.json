{
  "total_codes": 7,
  "detection_codes": [
    {
      "flag_value": 1,
      "detection_code": "df.loc[(pd.to_datetime(df['departure_datetime'], errors='coerce') > pd.to_datetime(df['arrival_datetime'], errors='coerce')) & df['departure_datetime'].notna() & df['arrival_datetime'].notna(), 'flag_status'] |= 1",
      "explanation": "This code detects rows where the departure date is after the arrival date by converting the 'departure_datetime' and 'arrival_datetime' columns to datetime objects and comparing them. It ensures that the departure date is always before the arrival date.",
      "test_description": "Test by checking if the 'flag_status' column is updated to 1 for rows where the departure date is after the arrival date.",
      "safety_notes": "Ensure that the 'departure_datetime' and 'arrival_datetime' columns contain valid datetime values for accurate detection."
    },
    {
      "flag_value": 2,
      "detection_code": "df.loc[(df['window_seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1']) & df['aisle_seat'].astype(str).str.strip().str.lower().isin(['true','t','yes','y','1'])), 'flag_status'] |= 2",
      "explanation": "This code detects rows where both window_seat and aisle_seat are marked as true, which is typically not possible.",
      "test_description": "Test by checking if the 'flag_status' column is updated to 2 for rows where both window_seat and aisle_seat are true.",
      "safety_notes": "Ensure that the 'window_seat' and 'aisle_seat' columns contain boolean values represented as strings ('true', 'false', 't', 'f', 'yes', 'no', 'y', 'n', '1', '0')."
    },
    {
      "flag_value": 4,
      "detection_code": "df.loc[((pd.to_datetime(df['arrival_datetime'], errors='coerce') - pd.to_datetime(df['departure_datetime'], errors='coerce')).dt.total_seconds() / 3600 != df['duration_hours']) & df['departure_datetime'].notna() & df['arrival_datetime'].notna() & df['duration_hours'].notna(), 'flag_status'] |= 4",
      "explanation": "This code detects rows where the duration_hours column does not match the actual difference between arrival and departure times. It calculates the time difference in hours between arrival and departure times and compares it with the duration_hours column.",
      "test_description": "To test this detection, you can create a sample dataset with departure_datetime, arrival_datetime, and duration_hours columns. Introduce a few rows where the duration_hours does not match the actual time difference between arrival and departure times. Apply the detection code and verify that the flag_status is updated for those rows.",
      "safety_notes": "Ensure that the departure_datetime, arrival_datetime, and duration_hours columns are properly formatted as datetime and numeric types respectively before running this detection code."
    },
    {
      "flag_value": 8,
      "detection_code": "# Fallback detection for flag 8\ndf.loc[df.index == -1, 'flag_status'] |= 8  # Placeholder",
      "explanation": "Fallback for Mismatch between layovers count and layover_locations entries.",
      "test_description": "This selects no rows. Replace with proper logic.",
      "safety_notes": "Safe but non-functional."
    },
    {
      "flag_value": 16,
      "detection_code": "df.loc[(df['flight_number'].notna() & (df['arrival_time'].isna() | (df['arrival_time'].astype(str).str.strip() == ''))), 'flag_status'] |= 16",
      "explanation": "This code flags rows where 'flight_number' is not missing, but 'arrival_time' is missing or empty.",
      "test_description": "Check if rows have a value in 'flight_number' but missing or empty 'arrival_time'.",
      "safety_notes": "Ensure that 'flight_number' is a required field and 'arrival_time' should not be missing or empty when 'flight_number' is present."
    },
    {
      "flag_value": 32,
      "detection_code": "df.loc[(pd.to_numeric(df['number_of_stops'], errors='coerce').fillna(0).astype(int) != df['layovers'].fillna('').astype(str).apply(lambda x: len([i for i in re.split(r'[;,|>]|->', str(x)) if i.strip()]))), 'flag_status'] |= 32",
      "explanation": "Checks for mismatch between number_of_stops and layovers",
      "test_description": "Create rows where number_of_stops does not equal number of items in layovers",
      "safety_notes": "Handles missing values, multiple delimiters (;,|,>,->)."
    },
    {
      "flag_value": 64,
      "detection_code": "df.loc[(df['status'].str.lower() == 'cancelled') & (df['gate'].notna() | df['terminal'].notna()), 'flag_status'] |= 64",
      "explanation": "This code flags rows where the flight status is 'Cancelled' but operational data like gate or terminal are filled.",
      "test_description": "Test by checking if the flag is correctly applied to rows where status is 'Cancelled' and gate or terminal are filled.",
      "safety_notes": "Ensure that the 'status' column values are normalized to lowercase before comparison to 'Cancelled'."
    }
  ],
  "generation_timestamp": "2025-09-01T18:24:16.223895",
  "llm_model": "gpt-3.5-turbo"
}